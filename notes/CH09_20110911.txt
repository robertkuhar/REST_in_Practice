Chapter 9:  Web Security

4 Pillars
  Confidentiality:
    The ability to keep information private while in transit or in storage
  Integrity:
    The ability to prevent information from being changed undetectably
  Identity:
    The ability to authenticate parties involved in an interaction
  Trust:
    Authorizing a party to interact with a system in a prescribed manner.

WWW-Authenticate header
  Basic Challenge:
    401 Unauthorized
    WWW-Authenticate: Basic realm="payments@restbucks.com"

  If the consumer knows username and password credentials for the realm, it hashes them and embeds them in an Authorization header and retries the request.
  Avoid the challenge by sending them in the Authorization header in the first place.
  HTTP Basic Authentication IS NOT SECURE
    HTTPS can secure the channel
    HTTP Digest Authentication allows credentials to be passed securely through an insecure channel

  Digest Challenge:
    401 Unauthorized
    WWW-Athenticate: Digest realm="payments@restbucks.com",
      qop="auth",
      nonce="1e8c46a7d793433490cb8303f18a86e5",
      opaque="ff1eccda9ef442b3b38cabb2435d5967"

    "nonce" - N - The one particular or present occassion.

    qop - Quality of Protection
          "auth" response based on HTTM method and digest URI only
          "auth-int" entity body included in respnose

    nonce - Opaque string used to prevent replay attacks
            Client may reuse a Nonce until the service rejects it with 401

    opaque - Information generated by the service that should be returned unchanged in the Authorization header of subsequent requests.

  Digest Response:
    GET /payment/1234 HTTP/1.1
    Host: restbucks.com
    Authorization: Digest username="beancounter",
      realm="payments@restbucks.com",
      nonce="1e8c46a7d793433490cb8303f18a86e5",
      uri="/payment/1234"
      qop="auth",
      nc=00000001,
      cnonce="cf45f0087f33bce12332aef430945dff",
      response="ff14aa3457acd60aa2091232a98756ff",
      opaque="ff1eccda9ef442b3b38cabb2435d5967"

    username - account name

    uri - URI of the resource to which the request is targeted
          /* I found the comment on load balancers rewriting the HTTP request interesting */

    nc - hex count of how many requests the consumer has made using the nonce
         /* why does this matter? */

    cnonce - The consumer's nonce
             generated for each request to prevent replay attacks
             /* How?  Why? */

    response - The result of apply a set of hash functions to the nonce, nonce count, consumer's nonce, and consumer's password.
               This is the value that the service will ultimately check to see whether the consumer has valid credentials for the realm.

    The "response" is calculated using a 3 step process
      1.  MD5 Hash of username, realm, and password is computed
      2.  MD5 Hash of the method and digest URI is computed
      3.  MD5 Hash of the value from Step 1, the service's {nonce, nc, cnonce, qop}, and Step 2 is calculated
          /* Wait, what?  How? */

    The consumer and the service have a "shared secret", the consumer's password.

    Unlike Basic authentication, Digest authentication always requires the Challenge/Response because the nonce and such metadata must be exchanged.
    Other benefits
      1.  Security Credentials are far less easily compromised because the password itself is not transmitted
      2.  The Authorization header's response value is never repeated which makes brute force attacks ineffective
    Man-in-the-middle attacks are still possible if transport-level security is not also employed.
      /* His example is somewhat faulty.  If the client is expecting Digest authentication, why would it participate in a Basic challenge? */

    The author calls out transport-level security as mandatory when HTTP authentication is in use.  /* I agree */
    HTTPS is Transport-level security

  Transport-Level Confidentiality and Integrity
    Primary benefits are ubiquity and maturity.  HTTPS is widely used, understood, and trusted.

    HTTPS
      Instead of exchanging HTTP requests and responses over TCP, we transmit those same requests and responses over TLS (Transport Layer Security).  TLS provides Integrity and Confidentiality.

      TLS evolved from Netscape's SSL (Secure Sockets Layer).

      TLS Protocol has 3 phases { Handshake, Secure Session, Channel Setup }
        Handshake
          3 way handshake is a TCP thing
        
        Secure Session
          The Client and the Server figure out what Version of TLS they will do and with which cipher and hash algorithms
          ServerCertificate is the service's Public Key (and optionally the service's name and Certificate Authority (CA))
          TLS can also do Client Side certs  (see note on P 292).

        Channel Setup
          Client sends a ClientKeyExchange message encrypted using the service's public key
          Subsequent client messages get hashed with the session key.
            Hashing a message with the session key creates a Message Authentication Code (MAC).

    /* Argh.  I still don't understand HTTPS, but I trust it. */

    Drawbacks to HTTPS ubber alles
      Scalability limits
        cryptogrophy costs
        CACHING IS BUSTED
    
    When designing these systems you must determine WHICH URIs need to be secure
      "What is the value of this resource?"
      "Who should be able to access this resource?"

    To get both Caching and Secure Interactions, we must find an alternative to encrypted channels.  We need patterns that allow us to encrypt content on unencrypted channels (which are cacheable).
      You basically publish the content encrypted and require the clients to have the key to decrypt it.
      Atom Publishing apparently supports this /* Damn, I'm pissed I missed the last meeting. */
      Management of the shared keys becomes a challenge

  Identity and OpenID Protocol
    HTTPS provids our Confidentiality and Integrity
    Next up:  Identity

    OpenID allows us to delegate Identity Management to someone else
      Consumers know the identity of services through their certificates
      Services come to know the identity of the consumers through their OpenID

      OpenID is compelling because of its simplicity
        /* The graph on P 296 is funky.  I like it. */

P306
