Chapter 9:  Web Security

4 Pillars
  Confidentiality:
    The ability to keep information private while in transit or in storage
  Integrity:
    The ability to prevent information from being changed undetectably
  Identity:
    The ability to authenticate parties involved in an interaction
  Trust:
    Authorizing a party to interact with a system in a prescribed manner.

WWW-Authenticate header
  Basic Challenge:
    401 Unauthorized
    WWW-Authenticate: Basic realm="payments@restbucks.com"

  If the consumer knows username and password credentials for the realm, it hashes them and embeds them in an Authorization header and retries the request.
  Avoid the challenge by sending them in the Authorization header in the first place.
  HTTP Basic Authentication IS NOT SECURE
    HTTPS can secure the channel
    HTTP Digest Authentication allows credentials to be passed securely through an insecure channel

  Digest Challenge:
    401 Unauthorized
    WWW-Athenticate: Digest realm="payments@restbucks.com",
      qop="auth",
      nonce="1e8c46a7d793433490cb8303f18a86e5",
      opaque="ff1eccda9ef442b3b38cabb2435d5967"

    "nonce" - N - The one particular or present occassion.

    qop - Quality of Protection
          "auth" response based on HTTM method and digest URI only
          "auth-int" entity body included in respnose

    nonce - Opaque string used to prevent replay attacks
            Client may reuse a Nonce until the service rejects it with 401

    opaque - Information generated by the service that should be returned unchanged in the Authorization header of subsequent requests.

  Digest Response:
    GET /payment/1234 HTTP/1.1
    Host: restbucks.com
    Authorization: Digest username="beancounter",
      realm="payments@restbucks.com",
      nonce="1e8c46a7d793433490cb8303f18a86e5",
      uri="/payment/1234"
      qop="auth",
      nc=00000001,
      cnonce="cf45f0087f33bce12332aef430945dff",
      response="ff14aa3457acd60aa2091232a98756ff",
      opaque="ff1eccda9ef442b3b38cabb2435d5967"

    username - account name

    uri - URI of the resource to which the request is targeted
          /* I found the comment on load balancers rewriting the HTTP request interesting */

    nc - hex count of how many requests the consumer has made using the nonce
         /* why does this matter? */

    cnonce - The consumer's nonce
             generated for each request to prevent replay attacks
             /* How?  Why? */

    response - The result of apply a set of hash functions to the nonce, nonce count, consumer's nonce, and consumer's password.
               This is the value that the service will ultimately check to see whether the consumer has valid credentials for the realm.

    The "response" is calculated using a 3 step process
      1.  MD5 Hash of username, realm, and password is computed
      2.  MD5 Hash of the method and digest URI is computed
      3.  MD5 Hash of the value from Step 1, the service's {nonce, nc, cnonce, qop}, and Step 2 is calculated
          /* Wait, what?  How? */

    The consumer and the service have a "shared secret", the consumer's password.

    Unlike Basic authentication, Digest authentication always requires the Challenge/Response because the nonce and such metadata must be exchanged.
    Other benefits
      1.  Security Credentials are far less easily compromised because the password itself is not transmitted
      2.  The Authorization header's response value is never repeated which makes brute force attacks ineffective
    Man-in-the-middle attacks are still possible if transport-level security is not also employed.
      /* His example is somewhat faulty.  If the client is expecting Digest authentication, why would it participate in a Basic challenge? */

    The author calls out transport-level security as mandatory when HTTP authentication is in use.  /* I agree */
    HTTPS is Transport-level security

  Transport-Level Confidentiality and Integrity
    Primary benefits are ubiquity and maturity.  HTTPS is widely used, understood, and trusted.

    HTTPS
      Instead of exchanging HTTP requests and responses over TCP, we transmit those same requests and responses over TLS (Transport Layer Security).  TLS provides Integrity and Confidentiality.

      TLS evolved from Netscape's SSL (Secure Sockets Layer).

      TLS Protocol has 3 phases { Handshake, Secure Session, Channel Setup }
        Handshake
          3 way handshake is a TCP thing
        
        Secure Session
          The Client and the Server figure out what Version of TLS they will do and with which cipher and hash algorithms
          ServerCertificate is the service's Public Key (and optionally the service's name and Certificate Authority (CA))
          TLS can also do Client Side certs  (see note on P 292).

        Channel Setup
          Client sends a ClientKeyExchange message encrypted using the service's public key
          Subsequent client messages get hashed with the session key.
            Hashing a message with the session key creates a Message Authentication Code (MAC).

    /* Argh.  I still don't understand HTTPS, but I trust it. */

    Drawbacks to HTTPS ubber alles
      Scalability limits
        cryptogrophy costs
        CACHING IS BUSTED
    
    When designing these systems you must determine WHICH URIs need to be secure
      "What is the value of this resource?"
      "Who should be able to access this resource?"

    To get both Caching and Secure Interactions, we must find an alternative to encrypted channels.  We need patterns that allow us to encrypt content on unencrypted channels (which are cacheable).
      You basically publish the content encrypted and require the clients to have the key to decrypt it.
      Atom Publishing apparently supports this /* Damn, I'm pissed I missed the last meeting. */
      Management of the shared keys becomes a challenge

  Identity and OpenID Protocol
    HTTPS provids our Confidentiality and Integrity
    Next up:  Identity

    OpenID allows us to delegate Identity Management to someone else
      Consumers know the identity of services through their certificates
      Services come to know the identity of the consumers through their OpenID

      OpenID is compelling because of its simplicity
        /* The graph on P 296 is funky.  I like it. */

  OpenID is a web-centric protocol.  It uses URIs as the basis for a consumer's identity claims, and hypermedia (XHTML forms and POST data) to bind the protocol steps together.

  OpenID4java is a Java implementation of OpenID

  The not on P309 cracks me up "...we learned this the hard way...Remember to URL-encode all of your OpenID representations...".  Although I am surprised that they wrote their own.  Doesn't Java library have one (http://download.oracle.com/javase/6/docs/api/java/net/URLEncoder.html)?

  /* The method signatures get rather confusing by Example 9-30.  Note the @PathParam annotation INSIDE of the argument list. */

P315:  OpenID provides Identity, OAuth provides Authorization.
  Authentication is "who"
  Authorization is "what"

P316:  "The OAuth protocol enables services and applications to interact with resources hosted securely in third-party services, without requiring the owners of those resources to share their credentials."

P317:  /* The first paragraph explains it all, but I don't understand. */
  "As the client, Restbucks never sees the credentials that the Resource Owner shares with the Voucher Service..."

  OAuth defines 3 types of credentials
    Client:     out-of-band between Client and Server (Voucher Service)
    Temporary:  used to bootstrap the OAuth protocol 
    Token:      used to allow access to protected resources once the protocol has completed

  Restbucks must establish trust with the voucher service
    Restbucks and Voucher Service establish an electronic domain of trust by sharing a set of client credentials.
      - These credentials comprise a "consumer key" and a "consumer secret"

    OAuth kicks in AFTER the user has attempted to pay with a voucher from the Voucher Service.
      "Restbucks (the client) must first obtain some Temporary credentials from the Voucher Service.  These Temporary creadentials can be used later in exhange for Token credentials.  We need Token credentials to redeem vouchers."

    P320 contains the Request/Response exhange

    /* THROUGHOUT THIS WHOLE SECTION...I am confused as to where the "shared secret" comes from.  It was set up with the Voucher Service beforehand?  That can't be. */

    /* I really didn't understand OAuth.  I bet it works, but he didn't do such a good job at explaining it. */

    /* The note on P325 regarding Redirects, and state changing GETs is interesting.  It seems that breaking from the Canon is often the case in RESTful APIs. */


    /* P326: "In the general case, sets of token credentials are valid for multiple interactions, which makes sense considering the effort involved in obtaining them! */

Pull out at P347 (which looks to be the beginning of a Java implementation)
